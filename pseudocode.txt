pseudocode

## Notes

# Invariants:
- Scheduled queue is always ordered by target time
- Scheduler does not make decisions (it schedules what it is asked to schedule)
- Orders with retry >= 3 are never retried again
- Order ID is set once by the order handler and is immutable after object creation
- Scheduler never schedules in the past

## Priority Queue Section ##
# Note:  Language implementation needs to account for zero-based array index (pseudocode uses 1-based).  Probably by using [heapSize -1] where heapsize is used as index.
Initialize:
	heapArray: an array of tuples containing order and scheduledTime
	heapSize: number of values in heapArray (initialized at zero and is incremented as elements are added to the heap array)

minHeapify (function): ## parameters are an array (A), the heap size (s), and the index to check (i)
	1. Establish index of parent, left, and right nodes:
		parent: i/2 (integer)
		left: 2i
		right: 2i + 1
	2. Select index of smallest scheduledTime out of A[i], A[left], A[right]
	3. If i (check index) does not contain smallest:
		Swap values of elements at indices i and smallest
		Call minHeapify on 'smallest' index (which is now broken)

bubbleUp (function): ## parameters are heapArray, insertIndex
	1. Establish index i = insertIndex and p = parent[insertIndex]
	2. Select index of smallest scheduledTime between heapArray[i] and heapArray[p]
	3. if value at i is smaller than value at p:
		Swap values
		Call bubbleUp with index p
		
insert (function) ## parameters are heapArray, heapSize, and the order tuple (order)
	1. Increment heapSize
	2. Place order tuple into heapArray[heapSize]
	3. Call bubbleUp on heapArray at heapSize

minimum (function) ## parameter is heapArray and heapSize
	1. Verify heapsize > 0
	2. Return heapArray[1]

extractMinimum (function) ## parameter is heapArray and heapSize
	1. Verify heapSize > 0
	2. Store heapArray[1] in temporary variable 'x'
	3. Place heapArray[heapSize] in heapArray[1]
	4. Decrement heapSize
	5. Call minHeapify on index i=1
	6. Return x


## Start ##
Initialize:
	time = 0
	Orders queue (queue)
	Scheduled queue (priority queue)
	History database (hash map, array, linked list, etc.)
	
Scheduler (function):
	1. Get current time
	2. Set target time using action's incremental time
	3. Add Order with Action and Target Time to Scheduled queue
	## Scheduled queue maintains a list of actions associated with orders prioritized by their target times

processPayment (function):
	1. Return 80% true 20% false ## Simulation can fail payments at 20% chance
	
processFulfillment (function):
	1. Return true ## Simulation always fulfills
	
processShipment (function):
	1. Return true ## Simulation always ships

Order Handler (Wait for order):
	1. Create a new order
	2. Mark status as Placed, update history database
	3. Add order to Orders queue
	4. Call scheduler (Order, Payment action, Payment time increment)
	
Action loop:
	0. If Scheduled queue is empty:
			Continue loop
	1. Peek Scheduled queue for target time of next action
	2. If time is on or after target time:
			Pop the Scheduled queue into a local object curr_order
		Else:
			Set time to target time  ## Speeds up simulation
			Continue loop
			
	3. If action is Payment:
		If curr_order retry is 3 or greater:
			Mark curr_order status as Failed
			Update history database
			Continue loop ## Order was popped out of the queue already, we'll rely on history db to show failed orders
			
		Else:
			Call processPayment function
			
			If processPayment succeeds:
				Mark status as Paid
				Update history database
			Else:
				Mark status as Payment_Failed_Retryable
				Increment Order retry counter
				Call Scheduler (curr_order, Payment Action, Failure time increment)
				Continue loop
				
			Call Scheduler (curr_order, Fulfillment action, Fulfillment time increment)
			Continue loop
	4. If action is Fulfillment:
			Mark status as Fulfilled
			Update history database
			Call Scheduler (curr_order, Shipment action, Shipment time increment)
			Continue loop
	5. If action is Shipment:
			Mark status as Shipped
			Update history database
		
			

	
